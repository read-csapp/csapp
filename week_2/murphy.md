# 整数表示

整数的表示，最为关键的地方就在于对于一串二进制数字的最高位的理解。

根据首位的理解的不同，我们可以将整数表示分为：

1. 无符号数（最高位权重为$2^{w-1}$）
2. 补码（最高位权重为$-2^{w-1}$）
3. 反码（最高位权重为$-2^{w-1}-1$）
4. 原码（最高位权重位符号位）

这里需要注意反码和源码对于0拥有+0和-0的两种表示方式，所以无法和无符号数进行一一对应（无符号数到反码或者源码的转换不是**双射**）。

其中我们最经常遇到的就是无符号数和补码。

但是补码和无符号数尽管是一一对应的，但是当数字进行补码到无符号数的**强转**时，因为底层对于数字存储的二进制数字并没有发生改变，只是计算机对其的解读发生了变化，所以在遇到数字最高位为1的情况下，其结果可能令不了解编码形式的人感到疑惑。

致于对于数字的**扩展**：

1. 对于无符号数字来说，就是简单的在多出来的高位上加0就可以了。
2. 对于补码来说，因为需要保证数字在扩张之后不会改变，则是需要在新增加的高位上补充自己曾经的高位数字，详情证明可参照csapp的P55。

而对于数字的**截断**：

1. 对于无符号数字来说，就是简单的将二进制表示的高位截断，
2. 对于补码来说，并没有保证其在阶段后的值不发生变化（也不可能保证），所以就是如同无符号数一般的对于其数字的二进制表示进行粗暴的截断，之后在对其进行解读（本质上也就是上面提到的**强转**）

因为补码和无符号数之间存在以上特殊的关系，导致的其在强转时容易出现难以排查的错误，所以比如Java语言就通过只支持补码来解决这个问题。

# 整数运算

无符号数和无符号数之间的四则运算，或者补码与补码之间的四则运算，本质上就是其数字的四则运算，在运算完毕之后对结果进行截断，之后对二进制数字表示进行对应的解读。

当然因为截断并不保证数字的正确性（包括不保证其正负情况的正确性），这就导致了其结果可能并非准确，这种情况称之为**溢出**。

同时因为数字的乘除运算较为消耗计算机时钟时间。但是可以通过移位的方法来加速一个数字*2``(使用<<2替代)``和/2``(使用>>2)``的效率，之后我们还可以通过 *2 和 /2 来想办法替换其他的乘法和除法，从而达到加速的效果。

当然，这里需要特别注意补码在移位的时候容易导致溢出，但是事实上，即使溢出，其结果和算术结果一致。

# 浮点数

浮点数这部分，关于数学证明并没有完全看完。内容有点多，没理出来总结的关键。决定在下周再多读一段时间再进行补充。

因为电脑对于我们生活中十进制数字的计算，本质上就是对于十进制数字映射成二进制数字进行计算之后，再将其解读为十进制。而因为我们电脑的计算与存储时有限的，所以我们需要认识到电脑所能够表示的二进制数字是有穷的。

但是在生活中，我们所遇到的数字是无穷的。

我们可以很直接的认识到，使用有穷的二进制数字来完美映射生活中无穷的数字是一件不可能实现的事情。

所幸，当我们在电脑中表示整数时，我们几乎不会使用到整整意义上达到了**无穷**状态的整数，即使是超过T或者超过P的情况下都比较稀少，这就导致了我们在绝大部分情况下都可以使用有限的二进制数字来精确的表示生活中遇到的整数。

但是当我们考虑到浮点数的时候，情况发生了变化。因为在浮点数中，任取两个浮点数，中间都存在着**无穷**的数字，这导致想使用二进制来精确表示浮点数的希望便彻底消失了。并且我们会在日常使用中经常性的遇到这些存在着**无穷**的状态的数字：比如圆周率：pi。

所以我们唯一能做的事情，就是想办法用又穷的二进制数字，洒在无穷的浮点数的长河中，当遇到二进制数字没有撒到的地方的时候，就以一定规律选取**附近**的二进制数字来进行表示。

但是当我们想要真正动手设计浮点数的时候，又会遇到一个难题：浮点数不像整数，只有无穷大和无穷小，他还有无穷接近于0。

我们必须意识到：**任意两个浮点数之间都蕴含着无穷**

因此，我们不仅要考虑到数字在数值的无穷大和无穷小，还要考虑到两个数字之间无限的可分。

如果浮点数的设计和整数相同，让两个数字之间的差距是固定的，我们必将会遇到以下情况：当我们想要更为**精确**的表示小数的时候，我么所能记录的数字**范围**就必须更小，当我们想要让能够记录的数字**范围**更大，其对于小数记录就会更为**粗糙**。

IEEE的标准，最为精髓的设计之处在于，其在讨论**附近**这个概念上时，使用了**工程**概念中的**附近**，而不是**数学**概念中的。

在工程上，我们对于精确的分析，一般是建立在我们所要分析的数字范围之上的。比如说当我们在制作一个几毫米的零件的时候，我们所关心的其尺寸的**精度**一般指的是**微米**，而在统计喜马拉雅山山峰的海拔的时候，我们关心的**精度**一般指的是**毫米**。

所以IEEE在设计浮点数标准的时候，使用了**阶码**来确定我们所要表示的数字的**最小精度**和**最大范围**，之后将其切成平均切成**尾数**数量的浮点数，让后将其洒在了无穷的浮点数长河中。在这段**阶码**中，相邻二进制数字的最小精度是固定。而不同**阶码**的**最小精度**和**最大范围**是**不同**的。

每次当我们为数字加上限制的时候，就不得不去面对数字超出限制的情况，比如整数计算中遇到的溢出，而浮点数在超出此段**阶码**限制的时候，我们就不得不使用一个其他**阶码**的数字来对其进行表示。这时，我们就必须在其**最小精度**和**最大范围**之间选择一个舍弃。

当然，在工程上，当我们切换阶码的时候，我们所遇到的损失一般是可以接受的。但是在特殊情况下，比如当因为阶码不同所带来的损失叠加在一起，就有可能变成一个在工程情况下也不可接受的bug。

如下面的代码所示：

```java
public class FloatPrecision {
  public static void main(String[] args) {
    float sum = 0.0f;
    for (int i = 0; i < 20000000; i++) {
      float x = 1.0f;
      sum += x;      
    }
    System.out.println("sum is " + sum);   //output:sum is 1.6777216E7
  }  
}
```

此处出现bug的主要原因是：当sum累加到一定阶码的情况下（准确的说是1.6777216E7），```x=1.0f```和sum的阶码相差过大，导致了在```sum += x;```的过程中x被sum忽略。确实，相较于1.6777216E7，忽略一个```x=1.0f```所导致的损失是不易引人注意的，但是当这部分损失大批量的叠加起来，就是不可接收的了。

所以此案的解决方法是，在累加过程中，将因为阶码所损失的数字汇聚在一起。每次sum在累加的时候，都将汇集起来的损失一起加在sum上。

详细实现如下：

```java
public class KahanSummation {
  public static void main(String[] args) {
    float sum = 0.0f;
    //在sum累加过程中，损失的数字的总和
    float c = 0.0f;
    for (int i = 0; i < 20000000; i++) {
      float x = 1.0f;
      //将损失的数字的和 c 累加在1上，在加到sum上去。
      float y = x - c;		
      float t = sum + y;
      //将sum + y过程中损失的数字存储到 c 中，等待下次循环
      c = (t-sum)-y;
      sum = t;      
    }
    System.out.println("sum is " + sum);   
  }  
}
```
