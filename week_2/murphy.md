# 整数表示

整数的表示，最为关键的地方就在于对于一串二进制数字的最高位的理解。

根据首位的理解的不同，我们可以将整数表示分为：

1. 无符号数（最高位权重为$2^{w-1}$）
2. 补码（最高位权重为$-2^{w-1}$）
3. 反码（最高位权重为$-2^{w-1}-1$）
4. 原码（最高位权重位符号位）

这里需要注意反码和源码对于0拥有+0和-0的两种表示方式，所以无法和无符号数进行一一对应（无符号数到反码或者源码的转换不是**双射**）。

其中我们最经常遇到的就是无符号数和补码。

但是补码和无符号数尽管是一一对应的，但是当数字进行补码到无符号数的**强转**时，因为底层对于数字存储的二进制数字并没有发生改变，只是计算机对其的解读发生了变化，所以在遇到数字最高位为1的情况下，其结果可能令不了解编码形式的人感到疑惑。

致于对于数字的**扩展**：

1. 对于无符号数字来说，就是简单的在多出来的高位上加0就可以了。
2. 对于补码来说，因为需要保证数字在扩张之后不会改变，则是需要在新增加的高位上补充自己曾经的高位数字，详情证明可参照csapp的P55。

而对于数字的**截断**：

1. 对于无符号数字来说，就是简单的将二进制表示的高位截断，
2. 对于补码来说，并没有保证其在阶段后的值不发生变化（也不可能保证），所以就是如同无符号数一般的对于其数字的二进制表示进行粗暴的截断，之后在对其进行解读（本质上也就是上面提到的**强转**）

因为补码和无符号数之间存在以上特殊的关系，导致的其在强转时容易出现难以排查的错误，所以比如Java语言就通过只支持补码来解决这个问题。

# 整数运算

无符号数和无符号数之间的四则运算，或者补码与补码之间的四则运算，本质上就是其数字的四则运算，在运算完毕之后对结果进行截断，之后对二进制数字表示进行对应的解读。

当然因为截断并不保证数字的正确性（包括不保证其正负情况的正确性），这就导致了其结果可能并非准确，这种情况称之为**溢出**。

同时因为数字的乘除运算较为消耗计算机时钟时间。但是可以通过移位的方法来加速一个数字*2``(使用<<2替代)``和/2``(使用>>2)``的效率，之后我们还可以通过 *2 和 /2 来想办法替换其他的乘法和除法，从而达到加速的效果。

当然，这里需要特别注意补码在移位的时候容易导致溢出，但是事实上，即使溢出，其结果和算术结果一致。

# 浮点数

浮点数这部分，关于数学证明并没有完全看完。内容有点多，没理出来总结的关键。决定在下周再多读一段时间再进行补充。