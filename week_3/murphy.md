# 程序的机器级表示

尽管我们使用高级语言编程的时候，机器屏蔽了程序的细节，即机器级实现。但是我们仍需要能够阅读和理解汇编代码来理解编译器的的优化能力。

机器级编程的两大核心抽象为：

1. 指令集体系结构或指令集架构。
2. 机器及程序使用的内存地址是虚拟地址。

注：在没有特别说明的情况下，本文的指令集架构为：x86-64

## 指令集体系结构或指令集架构

### x86-64和IA32

x86-64作为IA32的64位的版本，不难想象到，其需要兼容IA32架构的指令集来帮助用户从32位过渡至64位的版本。

所以我们不难想到，x86-64的指令应该分为IA32的32位指令集和自己新增的64位指令集。

当然，如果我们就从一个抽象的概念来考虑程序的实现，64位和32位的差距只是寻址时使用的地址的长度，在逻辑上并没有太大的区别。所以在之后就暂时不提32位和64位的区别。

### 指令集

最为常用的指令集主要包括三大类:

- 数据访问
  - 数据传送指令(mov)
  - 压入弹出栈数据指令(push,pop)
- 算数和逻辑操作
  - 加，减，乘，除，
  - 异或，或，与
  - 左移，右移
  - 加载有效地址。
- 控制
  - CMP，TEST
  - 访问条件码（set）
  - 转跳指令（jmp)

当然这些指令的详细内容和时间比较繁琐，书上都有写。

我个人感觉其中比较难以理解的地方在于使用状态码来控制程序的运行。

常用的状态码有四种：CF，ZF，SF，OF，其只有1和0两种状态。我们可以使用CMP和TEST可以设置状态码的状态，然后根据状态码的状态，使用jmp指令进行转跳来进行程序的控制。

其中，switch的转跳表值得额外关注一下。switch可以根据一个整数索引进行多重分支，通过**转跳表**来使得代码的实现更为高效。

当然，转跳表的底层实现是数组，这也局限了其的使用情况。其相较于if-else的效率，取决于开关情况的数量和开关情况的稀疏程度来决定。

举一个见到那的例子：假如case是：0，1，2，3，4，5，6，7，那么switch会自动建立转跳表，但如果case为：0，2，16，126，235，1563，那么再使用转跳表的效率反倒不如if-else，编译器就会自动选择if-else作为switch的实现。

