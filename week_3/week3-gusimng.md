# 程序的机器级表示

**数据格式**：大多数汇编指令都有一个字符的后缀，表明操作数的大小。

字符后缀 b 表示一个字节，字符后缀 w 表示一个字（两个字节），字符后缀 l 表示2个字（4个字节），字符后缀 q 表示4个字（8个字节）

操作数的可能性被分为三种类型，第一种类型是立即数，用来表示常数值；第二种类型是寄存器，它表示某个寄存器中的内容；第三种类型是内存引用，它会根据计算出来的地址访问某个内存位置。

对于第三种类型的操作数，通常有多种形式的寻址模式来指向内存中的某个地址。然而需要注意的是，**基址寄存器和变址寄存器都必须是64为的寄存器**，并且**比例因子必须是1、2、4、或者8。**

**数据传输指令MOV：**这些指令把数据从源位置复制到目的位置，不做任何变化。但是有两条限制条件：

1. 传送指令中的不能都指向内存位置。如果要将一个值从一个内存位置复制到另一个内存位置就必须使用两条传送指令。
2. 寄存器部分的大小必须与指令的字符后缀指定的大小匹配。

在将较小的源值复制到较大的目的时需要使用数据扩展传送指令。这样的指令分为两种，一种（MOVZ）是把目的中剩余的字节填充为0，而另一种（MOVS）则是通过符号位来填充。

需要注意的是，当movl指令以寄存器作为目的时，它会把该寄存器的高4字节设置为0。此外指令 movabsq 能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

**压栈和出栈指令：**pushq S，指令的效果是，先将%rsp中的值减8，然后再将S指定的值存储到%rsp所指向的内存（栈顶）中。

　　　　　　　　popq D，指令的效果是，先将%rsp中指向的内存地址中的内容复制到D中，然后%rsp中的值加8.

**算术与逻辑操作：**

一元操作指令：

INC　　D，效果是：D+1->D

DEC　　D，效果是：D-1->D

NEG　　D，效果是：-D->D

NOT　　D，效果是：~D->D

二元操作指令：

ADD　　S,D，效果是：D+S->D

SUB　　S,D，效果是：D-S->D

IMUL　　S,D，效果是：D*S->D

XOR　　S,D，效果是：D^S->D

OR　　S,D，效果是：D|S->D

AND　　S,D，效果是：D&S->D

SAL　　k,D，效果是：D<<k->D

SHL　　k,D，效果是：D<<k->D

SAR　　k,D，效果是：D>>Ak（算术右移）

SHR　　k,D，效果是：D>>Lk（逻辑右移）

**特殊的算术操作：**

imulq　　S、mulq　　S：一个是补码乘法，一个是无符号乘法。这两条指令都要求一个参数必须在寄存器%rax中，而另一个操作数作为指令的源操作数给出。然后乘积的高64位放在%rdx中，低64位放在%rax中。

idivq　　S、divq　　S：一个是补码乘法，一个是无符号乘法。这两条指令将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。然后将商存放在寄存器%rax中，将余数存储在寄存器%rdx中。通常，寄存器%rdx会事先设置为0.

clto　　S：转换为八字

**条件控制码：**

CF：进位标志，最近的操作是最高为产生了进位时等于1，用于检查无符号操作的溢出。

ZF：零标志，最近的操作得出结果为0时等于1。

SF：符号标志，最近的操作得到的结果为负时等于1。

OF：溢出标志，最近的操作导致一个补码溢出——正溢出或负溢出。

除了上述的逻辑运算与算术运算会改变条件码外，下面两条指令也能改变条件码：

CMP　　S1, S2，根据两个操作数之差来设置条件码。

TEST　　S1, S2，该指令的行为与AND一样，但是这条指令只设置条件码而不会改变目的寄存器的值。典型的用法为testq　　%rax, %rax，用于检查%rax是否为0

**Switch语句：**

switch语句可以根据一个整数索引值进行多重分支。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了C代码的可读性，而且通过是同跳转表这种数据结构使得其实现更加高效。跳转表是一个数组，表项 i 是一个代码段的地址，这个代码段实现当索引值等于 i 时程序应该采取的动作。

jmp指令的操作数有 前缀 ' * ' ，表明这是一个间接跳转，操作数指定一个内存位置，而索引由寄存器%rsi给出。

**过程：**

过程调用，过程P调用过程Q：

**转移控制**，将控制从函数P转移到Q只需要简单地把程序计数器(PC)设置为Q的起始地址。不过当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码的位置。指令call　Q，可以调用过程Q，这条指令会把地址A压入栈中，并将PC置为Q的起始地址。压入的地址A被称为返回地址，是紧跟call指令后面的那条指令的地址。对应的 ret 指令会从栈中弹出地址A，并把PC设置为A。

**数据传送**，当调用一个过程时，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。可以通过寄存器最多传递6个整形参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于传递的数据类型的大小。如果一个函数有大于6个整型参数，那么超出6 个的部分就要通过栈来传递。

**运行时栈**：

栈向低地址增长，而栈指针%rsp始终指向栈顶元素。可以用 pushq 和 popq 指令将数据存入栈中或者是从栈中取出来，而将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。

当过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这部分空间被称为过程的栈帧。

**一个进程对应于一个栈，一个函数（过程）对应于一个帧。**