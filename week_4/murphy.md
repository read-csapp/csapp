# Arrays

如果我们是设计计算机的人，需要我们对一维数组这样一个数据结构进行设计，不难想到摆在我们面前的有两种直觉性的方案：

1. 用一段连续的内存来存储一个数组。
2. 用不连续的内存来存储一个数组。

这两种方式最大的区别在于，如果使用连续的内存来进行存储的话，我们其实只需要整个数组的一个位置，就可以找到数组中其他元素所在的位置。

而如果使用不连续的内存来存储一个数组，我们就得记录下这些数组中各个元素的所在位置。而这些位置又需要找一个等规模的数组进行存储。一个数组的创建需要创建一个和他等大的数组，这种无限递归的解决方案肯定是错误的，那么只有第一种方案可以选择了。

致于关于多维数组的实现，本质上也就是把多个连续的数组紧凑的放到了一个连续的内存中，然后通过传入的索引，和这个数组本身的大小，通过乘法和加法来根据数组的一个地址算出我们想要取出的数据的地址。

但是这种多维数组有个毛病，就是多维数组中的子数组的大小都必须是一致且确定的，这样才好让编译器通过多维数组建立时的参数来计算出对应数据地址的偏移量。假设我们设计中的二维数组中的每个子数组的长度都是不一致的，甚至有可能是动态地。这样编译器也没办法开辟一个连续的空间来完成这个需求。

这时候，只是是使用一段连续内存存储数组的方案就无法解决这个问题了。要解决这个问题，需要将第一个数组设计方案和第二个数组设计方案结合来使用。

我们知道，我们只需要知道一个连续数组中，其中一个元素的地址，其实我们就知道了整个数组中其他元素的地址。这个地址其实就代表了整个数组。所以我们只需要让一个数组中，存储多个连续数组中的其中一个元素的地址，就可以实现一个二维数组，即使多个连续数组在空间上并不来连续。致于子数组到底详细结构时什么样子的，我们的数组并不关心，那是子数组自己要维护的事情。

当然，事情有利就有弊。首先就是寻址次数的问题。因为我们自己通过地址创建的二维数组的子数组之间地址并不连续，所以我们得先找到其子数组的位置，然后在找到我们想要找到的元素的位置。而如果我们使用原生的二维数组，因为所有元素都是连续的，并且子数组的大小是固定的，所以只需要一次寻址。当然其实多一次寻址的过程，并不是一个巨大的开销，尽管这个开销的差距在随着数组维数的增加而增加。真正麻烦的事情是：**地址（指针）**。

尽管，本质上，一个连续数组中的一个元素的地址，其实就可以代表整个数组的地址。但是地址和数组有着本质上的不同。

数组，代表着一片已经被开辟出的地址空间。而地址，只是指向内存的一串数字，它指向的内存是否存在，是否合法，是否正确都是一个未知数。

一个非法的指针会让整个程序崩溃，尤其是当我们想把数组和指针结合起来，指针指着数组，数组装着指针的时候，就更容易犯错。

举个例子：

|      | int  A1[3] | int *A2[3] | int (*A3)[3] |
| ---- | ---------- | ---------- | ------------ |
| An   | 12         | 24         | 8            |
| *An  | 4          | 8          | 12           |
| **An | -          | 4          | 4            |

上面的表格代表着这三种数组声明中，对应元素的大小。

其中，A1代表着一个容量为3的连续数组，数组中的每个元素都是一个int.

而A2代表也是一个容量为3的连续数组，不过数组中的每一个元素都是一个指向int类型的指针。

而A3代表着是一个指针，这个指针指向了一个容量为3的int数组。

# 指针安全

其实自己编写的代码，总归是比较安全的。当我们使用指针的时候，最不安全的地方在于，指针有可能被他人利用来运行一些他人的代码。而c语言中没有边界检查的，可以进行指针运算的指针，就成了最容易收到攻击的地方。

想象这么个场景，你开发的一个接口，从外部读入了一串字符串。你的程序将这个字符串压入了栈中。之后调用的子方法的数组在进行指针运算的时候，通过指针操作了你所存储的程序返回地址，让他指向了你之前压入栈中的字符串。当程序ret之后，他会将程序计数器指向之前压入栈中的字符串，然而这个字符串是外部人所编写的代码，导致了严重的安全问题。这就是缓冲区溢出攻击。

目前，编译器为了防止这种现象，有三种解决方案：

1. 栈随机化
2. 栈破坏检测
3. 限制可执行代码区域。

当然，这三种方案结合起来，也不能完全保证整体代码的安全性，但是也足以让攻击者没有那么容易得手。增大了攻击者攻击的代价。

# Structures

结构体本身的存储逻辑其实和数组并没有什么区别。他们两者的唯一区别就是结构体的各个元素的大小并不一致。

并且在intel等的开发手册建议下，现在绝大多数的结构体在开辟空间的时候，都会将不规整的元素进行对齐，让cpu进行跟为快速的计算，这导致结构体和数组的差距就更小了。

而这个对齐的习惯，则是我们在编程的时候需要注意到的。我们可以通过结构体 的对齐规则，来设计结构体元素的先后顺序，从而让结构体所占用的空间更小。