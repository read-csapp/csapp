- 条件码用于控制。最常用的四个是，CF: 进位标志，ZF：零标志，SF：符号标志，OF：溢出标志 

-  通过SET指令访问条件码，入sete/setz %al就是将ZF设置到%eax的最低byte上（0或1） 

-  jmp表示跳转指令，一般汇编用一个标号来指定，如jmp .L1。也可以利用寄存器，如jmp *%rax表示跳转到%rax的值的地址，jmp *(%rax)表示跳转到%rax值对应的内存值的内存地址去。和SET一样，也有je，js，jle等指令 

-  GCC当switch的情况较多，且跨度较小的时候，会使用地址跳转表来翻译switch 

-  当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就回在栈上分配空间，这个部分称为过程的栈帧 

-  call指令用于函数调用，此时将会把将紧跟着当前地址后面的那条指令的地址压入栈，并吧要跳转的函数地址设置到PC。退出时用ret。 

- ### 缓冲区溢出

  通常，在栈中分配某个字节数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。C对于数组引用不进行任何边界检查，而且局部变量和状态信息，都存在栈中。这样，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。

  缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行ret指令的效果就是跳转到攻击代码。

  通常，使用gets或其他任何能导致存储溢出的函数，都不是好的编程习惯。不幸的是，很多常用库函数，包括strcpy、strcat、sprintf，都有一个属性——不需要告诉它们目标缓冲区的大小，就产生一个字节序列。
  

- ###  局部数据存到需要内存中的几种情况： 

  1. 寄存器不够用
  2. 对局部变量使用了地址运算符&
  3. 某些局部变量是数组或结构体（如果优化了则不一定）

- 数据对齐可提高软件性能，减少读的次数和额外的处理。无论数据是否对齐，x86-64都可以正确工作。汇编中在文件头部声明.align 8来保证后面的数据的起始地址都是8的倍数。 

-  对于结构体，字段之间也可能会存在间隙，以保证每个结构元素都满足它的对齐需求。 

-  对齐原则是任何K字节的基本对象的地址必须是K的倍数。 

-  Linux上最新版的GCC已经会讲栈地址随机化，使得栈溢出攻击变得更加困难