虚拟内存
物理地址：计算机的主存被组成一个由M个连续字节大小的单元组成的数组，每个字节都有唯一的物理地址。CPU使用这种地址就叫做物理寻址
现代操作系统使用虚拟寻址，CPU生成的是虚拟地址（Virtual Address，VM），由MMU翻译成物理地址。地址翻译需要硬件和操作系统紧密合作。CPU上有内存管理单元（MMU）利用存放在主存上的查询表来动态翻译虚拟地址，该表的内容有操作系统内核管理

地址空间
在一个带虚拟地址的系统中，CPU在一个N=2n个地址的地址空间生成虚拟地址，每个地址空间称为虚拟地址空间。这里的n就是地址空间大小，也就是常说的系统是32位还是64位
地址空间的概念成功区分了数据对象（字节）和它们的属性（地址）。虚拟内存的基本思想就是允许每个数据对象有多个独立的地址，每个地址都选自不同的地址空间。因此对于主存中的字节都有一个来自虚拟地址空间的虚拟地址和一个来自物理地址空间的物理地址

缓存
逻辑上讲，虚拟内存被组成一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。磁盘上的数据被缓存到主存中。因为磁盘和主存的传输单元为块，VM系统通过将虚拟内存分为虚拟页（VP）大小的固定块来做统一，同样物理页（PP）也分割为同样大小的块，称为页帧
为了讨论清晰，用SRAM缓存表示位于CPU和主存之间的L1、L2和L3高速缓存，用DRAM表示虚拟内存系统的缓存，它在主存中缓存虚拟页
页表
虚拟内存系统需要判断虚拟页是否缓存在DRAM中，并确定是在哪个物理页上，如果没有缓存，系统要判断存放在磁盘的位置，并将其复制到DRAM中

这些功能需要操作系统软件、MMU中的地址翻译软件和一个存放在物理内存中的叫做页表（Page table）的数据结构联合提供。
CPU输出一个VA到MMU的地址翻译硬件，其将VM作为一个索引来定位在页表中的位置（如定位到了PTE 2），由于PTE 2的有效位为1，地址翻译硬件就知道要找的数据就存放在DRAM中，也就是命中，之后就会使用有效位接下来的物理内存地址，构造数据的物理地址
如果没有命中，也就是虚拟地址索引的PTE有效位为0，就发生缺页异常，这会调用内核中的缺页异常调用程序。程序会在DRAM中选择一个牺牲页，将其复制回磁盘，并修改页表。接下来就是根据磁盘地址从磁盘中把缺页复制到内存中。当异常处理程序返回时，就会重启导致缺页的指令。这种直到不命中时，才将页从DRAM换入或换出磁盘的策略就叫按需页面调度
虽然页面调度的处罚代价非常高，但是虚拟内存工作的非常好，因为局部性。因此只要程序有良好的时间局部性，虚拟内存系统就能工作的相当好

地址翻译
地址翻译是一个N元素的虚拟地址空间（Virtual Area Space，VAS）中的元素和一个M元素的物理地址空间（PAS）中元素的映射
CPU中有一个页表寄存器（PTBR），指向当前页表，虚拟页号根据当前页表找到PTE，MMU根据得到的PPN和PPO组合出新的物理地址
当页表命中时，完全是由硬件在处理。MMU根据虚拟地址和当前页表寄存器值得出PTE的地址，并送给Cache/主存，返回PTE之后，组合得到物理地址，再一次向主存/Cache请求，得到数据
当发生缺页时，就要硬件和操作系统内核协作完成。MMU首先检测到得到的PTE的有效位为0，就会触发异常，CPU检测到这个异常，就会根据异常表，跳转到内核的缺页异常处理程序，由内核来将缺页读入主存，最后处理程序返回，CPU重新发送缺页指令
为了消除MMU每次都要向内存查询PTE，通常在MMU中设置一个关于PTE的小缓冲（Translation Lookaside Buffer，TLB），这样读取PTE的周期从几百个降到了几个
多级页表
这种方式减少了内存要求，第一如果第一级页表中的PTE为空，相应的二级页表就不会存在，第二只有一级页表总是存在主存中，二级页表只在需要时创建，并缓存在主存中

内存映射
Linux通过一个虚拟内存区域与一个磁盘对象关联起来，以初始化这个虚拟内存区域的内容
进程使用该mmap函数创建新的虚拟内存区域，并将对象映射到这些区域中
void *mmap(void *start,size_t length,int prot,int flags,
	int fd,off_t offset);
动态内存分配
使用动态内存分配器具有更好的移植性。显式分配器就是类似于C中的malloc，隐式分配器就类似于Java中的垃圾回收9
动态内存分配器维护着一个进程的虚拟内存区域，称为堆

垃圾回收
也是一种动态内存分配器，它自动释放程序不再需要的已分配块
