### 地址管理

当一个进程想要访问内存，如果访问的都是物理内存的话，这就容易乱套了，这样程序员和编译器都很难看。当然啦，现在现在只有几k内存的单片机就是这么做的，关键是人家也不用那么复杂呀，就是可能是亮一个LED灯泡就行了。


所以就给进程安排个虚拟内存呗，让进程觉得自己的小盒子就是整个世界（用gcc编译出来的汇编代码的地址都是一样的，链接的时候去重定向），想怎么用怎么用，当然他也能时常仰望星空（内核空间），但是一旦出去就会被打回来（报错）。如果想买点地盖个房（write）或者看点其他人的房产记录（read）咋办呢，和政府去申请呗（系统调用），他是真的啥权限都用。


这个时候政府的压力就大了，还有管理一个个进程小盒子（虚拟内存管理）还要管理各个小盒子能用真实空间（物理内存管理），所以政府就负责两者之间的对应关系（虚拟内存到物理内存的映射）。


盒子越来越多，但是他们问的常见问题就那个几个，所以把那些放在最快能给他们的地方（TLB），还有次常用的就放在大厅里面谁来看（放在内存中的虚拟内存页），如果有比较便的问题就去咱们的仓库里面拿（放在磁盘上的虚拟内存页）


### 内存分配

这对于政府来说是个难题了，有的要大块地，有的小块的地咋办呢。他们之间在政府（内核）中的分配不一样，政府分配最小单位（一页=4K），当大约一定量的时候用mmap，小量的时候用brk，还有些不到最小单位的，政府就把最小单位（4K）分了，等着给人用。如某个系统经常申请大块空间咋办勒，就把最小单位调大一些（内存大页，4M或者更大），这样分配的最小单位就小了。


如果是线性分配，就会出现随便，那么空间合并是个重要问题（内存碎片）。
